require 'creek'

module Rximport
  class Parser

    attr_accessor :sheet_index, :data_start_index, :has_titles, :title_index
    attr_reader :mapper

    # Options:
    # - :remote       Set this to true if file is an url
    # - :data_start_index     index of the row where the data starts (default 1)
    # - :sheet        Sheet number to parse. Zero indexed
    # - :has_title    whether or not the sheet has a title row (default true)
    # - :title_index  row index of the title row (default 0)
    # - :mapper       An instance of a Mapper class to map column names to attribute names.
    #
    # Example:
    #   import = Import.last
    #   parser = Parser.new(import.sku_data_url, remote: true)
    #   skus = parser.rows.map { |attributes| Sku.new(attributes)
    #   skus.import
    def initialize(file, options = {})

      default_options = {
          remote: false,
          data_start_index: 1,
          sheet: 0,
          has_titles: true,
          title_index: 0,
          mapper: nil
      }

      @options = default_options.merge(options)

      self.data_start_index = @options.delete(:data_start_index)
      self.title_index = @options.delete(:title_index)
      self.sheet_index = @options.delete(:sheet)
      self.has_titles = @options.delete(:has_titles)
      self.mapper = @options.delete(:mapper)

      # We need to create a tmp file manually if remote file is used.
      # This is because the Tmpfile generated by Creek::Book will be deleted
      # after accessing all rows once and results in File not found error
      # for each subsequent access to the sheet.
      @file = options.fetch(:remote, false) ? create_tmp_file(file) : file

      # do not check file extension, we already do that in the uploader
      @creek = ::Creek::Book.new @file,check_file_extension: false
    end

    # Set the a mapper
    # @param [Mapping::Base] value The mapper to use when using #mapped_rows
    def mapper=(value)
      unless value.nil? || value.respond_to?(:apply)
        raise 'mapper must respond to #apply(values).'
      end

      @mapper = value
    end

    def titles
      title_row.values
    end

    # @return [Array<Column>]
    def columns
      columns = []
      title_row.each_with_index do |(key, value), index|
        columns << Column.new(index, value, key)
      end
      columns
    end

    # returns a lazy enumerator for the data rows in the excel sheet
    def rows
      rows_to_skip = data_start_index
      cached_columns = columns

      data_rows = sheet.simple_rows.lazy
                      .drop(rows_to_skip)
                      .map { |r| Row.new(cached_columns, r) }
                      .reject(&:blank?)

      data_rows.map do |row|
        if block_given?
          yield row
        else
          row
        end
      end
    end

    # Returns a lazy enumerator with applied mapping.
    # If no mapper is configured in options, it will be
    # the same as #rows
    # @param [Mapping::Base] custom_mapper Overwrite the mapper set on initialization
    def mapped_rows(custom_mapper = nil)
      local_mapper = custom_mapper || mapper
      return rows if local_mapper.nil?

      rows do |row|
        mapped = local_mapper.apply(row)
        if block_given?
          yield mapped
        else
          mapped
        end
      end
    end

    # Returns the values of the given column
    def values(column)
      rows do |row|
        row[column]
      end
    end

    # Returns an enumerator of distinct values of the
    # given column
    def values_distinct(column)
      values(column).uniq
    end

    def title?
      has_titles
    end

    def sheet
      @creek.sheets[sheet_index]
    end

    def close
      @creek.close
      File.unlink(@file) if options.fetch(:remote, false)
    end

    private

    def title_row
      return [] unless title?
      sheet.simple_rows.lazy.drop(title_index).first
    end

    def create_tmp_file(uri)
      tmpfile = Tempfile.create('import')
      tmpfile.binmode
      tmpfile.write(HTTP.get(uri).to_s)
      tmpfile.close
      tmpfile.path
    end

  end
end